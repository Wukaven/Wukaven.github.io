<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RabbitMQ  Docker部署</title>
    <url>/2021/07/23/RabbitMQ%E7%9A%84Docker%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>一、docker上部署启动RabbitMQ</p>
<span id="more"></span>

<p>1、查询rabbitmq镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>2、拉取rabbitmq镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>3、创建并启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.1创建和启动</span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -p 8080:15672 rabbitmq:management</span><br><span class="line">其中：</span><br><span class="line"></span><br><span class="line">--hostname：指定容器主机名称</span><br><span class="line">--name:指定容器名称</span><br><span class="line">-p:将mq端口号映射到本地</span><br><span class="line"></span><br><span class="line">3.2备选启动同时设置用户和密码</span><br><span class="line">docker run -d --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 -p 25672:25672 -p 61613:61613 -p 1883:1883 rabbitmq:management</span><br><span class="line">注意：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 15672：控制台端口号</p>
<p> 5672：应用访问端口号<br>此处的端口访问是有区别的，控制台端口用于管理rabbitmq，应用访问端口号为rabbitclient等应用访问。</p>
<p>3.3查看rabbitmq运行状况：<br>docker logs rabbit</p>
<p><img src="https://files.mdnice.com/user/11714/0cf18edb-1a3b-4f83-a7cc-737731bb844b.png"></p>
<p>4、访问</p>
<pre><code>http://localhost:15672
</code></pre>
<p>5、登录</p>
<pre><code>默认账户名：guest

密码：guest
</code></pre>
<p>提醒，如果关闭计算机时未停止这个启动的容器，再次启动docker时会出现无法访问15672的情况，此时只需停止并移除这个容器，然后重启一次docker，重新执行启动rabbitmq容器的命令即可。</p>
<p>二、使用RabbitMQ</p>
<p>1、创建sender</p>
<p>a、构建消息提供者类sender</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package org.vertx.vertx.rabbitmq.example;</span><br><span class="line"> </span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"> </span><br><span class="line">public class Send &#123;</span><br><span class="line">	</span><br><span class="line">	private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"> </span><br><span class="line">	  public static void main(String[] argv)throws java.io.IOException, TimeoutException &#123;</span><br><span class="line">		  ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">		  factory.setUsername(&quot;guest&quot;);</span><br><span class="line">		  factory.setPassword(&quot;guest&quot;);</span><br><span class="line">		  factory.setHost(&quot;localhost&quot;);</span><br><span class="line">		  factory.setPort(5672);</span><br><span class="line">		  factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">		  Connection connection = factory.newConnection();</span><br><span class="line">		  Channel channel = connection.createChannel();</span><br><span class="line">		  channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">		  String message = &quot;Hello World!&quot;;</span><br><span class="line">		  channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());</span><br><span class="line">		  System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">		  channel.close();</span><br><span class="line">		  connection.close();</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    b、启动后可查看消息队列。</span><br><span class="line"></span><br><span class="line">    c、访问链接</span><br><span class="line"></span><br><span class="line">    http://127.0.0.1:15672/#/queues</span><br><span class="line"></span><br><span class="line">     可见，RabbitMQ management中name为hello的消息产生一条。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/11714/2b12c882-1924-4dcd-a39f-f2dfcb8770c8.png"></p>
<p>2、创建receiver</p>
<p>a、创建消息接收方的类receiver。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.vertx.vertx.rabbitmq.example;</span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">public class MyConsumer &#123;</span><br><span class="line">	</span><br><span class="line">	  private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"> </span><br><span class="line">	  public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">	    ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">	    factory.setUsername(&quot;guest&quot;);</span><br><span class="line">		factory.setPassword(&quot;guest&quot;);</span><br><span class="line">		factory.setHost(&quot;localhost&quot;);</span><br><span class="line">		factory.setPort(5672);</span><br><span class="line">		factory.setVirtualHost(&quot;/&quot;);</span><br><span class="line">		factory.setConnectionTimeout(600000); // in milliseconds</span><br><span class="line">		factory.setRequestedHeartbeat(60); // in seconds</span><br><span class="line">		factory.setHandshakeTimeout(6000); // in milliseconds</span><br><span class="line">		factory.setRequestedChannelMax(5);</span><br><span class="line">		factory.setNetworkRecoveryInterval(500); </span><br><span class="line">	    </span><br><span class="line">	    Connection connection = factory.newConnection();</span><br><span class="line">	    Channel channel = connection.createChannel();</span><br><span class="line"> </span><br><span class="line">	    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">	    System.out.println(&quot;Waiting for messages. &quot;);</span><br><span class="line"> </span><br><span class="line">	    Consumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">	      @Override</span><br><span class="line">	      public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)</span><br><span class="line">	          throws IOException &#123;</span><br><span class="line">	        String message = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">	        System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">	    channel.basicConsume(QUEUE_NAME, true, consumer);</span><br><span class="line">	  &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b、启动receiver并访问链接</p>
<p>c、运行后可接收到消息</p>
<p>d、访问管理器查看消息队列</p>
<p><a href="http://127.0.0.1:15672/#/queues">http://127.0.0.1:15672/#/queues</a></p>
<p><img src="https://files.mdnice.com/user/11714/26ef77e2-5348-44d9-8019-b2a98edd79c1.png"></p>
<p>消息队列中hello的消息条数为0，已发送至接收方。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「小召123566」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_39617052/article/details/79723849">https://blog.csdn.net/weixin_39617052/article/details/79723849</a></p>
]]></content>
      <categories>
        <category>RabbitMQ的学习</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo个人博客部署</title>
    <url>/2021/07/23/hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="上传github，文件不全"><a href="#上传github，文件不全" class="headerlink" title="上传github，文件不全"></a>上传github，文件不全</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d </span><br><span class="line">之后上传文件之后没有public 删除 myblog/.deploy_git 。然后重新生成上传</span><br><span class="line"></span><br><span class="line">如果无法方问请确认镜像仓库的名称和GitHub名称一致</span><br><span class="line">https://github.com/Wukaven/Wukaven.github.io</span><br><span class="line">访问：https://wukaven.github.io  就可以访问</span><br></pre></td></tr></table></figure>
<h2 id="部署具体的hexo可以参考文档"><a href="#部署具体的hexo可以参考文档" class="headerlink" title="部署具体的hexo可以参考文档"></a>部署具体的hexo可以参考文档</h2><p>我所使用的hexo的<a href="https://github.com/Shen-Yu/hexo-theme-ayer">主题</a>和hexo的<a href="https://hexo.io/zh-cn/">官网</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro的快速启动</title>
    <url>/2021/07/23/Spring/Shiro%E7%9A%84%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>Apache Shiro的设计目标，是通过直觉化的设计，来简化程序安全开发，并且简单易用。Shiro核心设计模型符合大众对程序安全的理解—-程序的安全存在于人（或其它任何东西）和系统交互的上下文环境中.<br><strong>Shiro的默认实现中，包含如下：</strong><br>授权、鉴权、session管理、cache管理、Realm管理、事件传播、Rmember Me服务、Subject创建、登出及更多、</p>
<span id="more"></span>
<h2 id="Shiro架构有三个主要的概念：Subject，SecurityManager、Realm"><a href="#Shiro架构有三个主要的概念：Subject，SecurityManager、Realm" class="headerlink" title="Shiro架构有三个主要的概念：Subject，SecurityManager、Realm"></a>Shiro架构有三个主要的概念：<strong>Subject，SecurityManager、Realm</strong></h2><p>Subject :相当于门户，程序安全视角的user。Subject 的实例都绑定在SecurityManager上。当你和subject交互时，都是由SecurityManager来进行转换的。  </p>
<p>SecurityManager：SecurityManager是Shiro架构的核心，他扮演着伞对象的角色（持有各组件引用，协调调用），来协调它内部的安全组件，他们一块来形成对象视图。然而，一旦程序中的SecurityManager和他内部对象已经配置好，通常上就不用再管他，程序的开发人员几乎大部分时间都会花在Subject API上。当你和Subject交互时，所做的任何Subject的安全操作，实际上是SecurityManager在幕后辛苦劳作。   </p>
<p>Realms：Realms在Shiro和你的程序安全数据之间，扮演着桥梁或者连接器的角色。当和安全相关数据有交互时，比如用户登录校验和鉴权，Shiro通过程序中配置的一个或者多个Realm来查询。 </p>
<h2 id="一、四大基石—-身份验证，授权，会话管理，加密"><a href="#一、四大基石—-身份验证，授权，会话管理，加密" class="headerlink" title="一、四大基石—-身份验证，授权，会话管理，加密"></a>一、四大基石—-身份验证，授权，会话管理，加密</h2><p>1.Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</p>
<p>2.Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p>
<p>3.Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</p>
<p>4.Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</p>
<h1 id="二、快速开始"><a href="#二、快速开始" class="headerlink" title="二、快速开始"></a>二、快速开始</h1><p>shiro主要拥有三个角色 Subject，SecurityManager、Realm。</p>
<ol>
<li> 引入依赖，编写shiroConfig</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line">    /**</span><br><span class="line">     * ShiroFilterFactoryBean 处理拦截资源文件问题。</span><br><span class="line">     * Filter Chain定义说明 1、一个URL可以配置多个Filter，使用逗号分隔 2、当设置多个过滤器时，全部验证通过，才视为通过</span><br><span class="line">     * 3、部分过滤器可指定参数，如perms，roles</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) &#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();</span><br><span class="line"></span><br><span class="line">        // 必须设置 SecurityManager</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面</span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);</span><br><span class="line">        // 设置登录成功后要跳转的链接</span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);</span><br><span class="line">        // 设置未授权界面;</span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/403&quot;);</span><br><span class="line"></span><br><span class="line">        // 拦截器.</span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        //# 配置不会被拦截的链接 顺序判断 有多重默认的过滤器</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/static/**&quot;, &quot;anon&quot;);</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/ajaxLogin&quot;, &quot;anon&quot;);</span><br><span class="line"></span><br><span class="line">        // 配置退出过滤器,其中的具体的退出代码Shiro已经替我们实现了</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;);</span><br><span class="line">        #添加</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/add&quot;, &quot;perms[权限添加]&quot;);</span><br><span class="line"></span><br><span class="line">        // &lt;!-- 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了;</span><br><span class="line">        // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt;</span><br><span class="line">        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);</span><br><span class="line"></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        System.out.println(&quot;Shiro拦截器工厂类注入成功&quot;);</span><br><span class="line">        return shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean        # 管理器</span><br><span class="line">    public SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        // 设置realm.</span><br><span class="line">        securityManager.setRealm(myShiroRealm());</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 身份认证realm; (这个需要自己写，账号密码校验；权限等)</span><br><span class="line">     * </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public MyShiroRealm myShiroRealm() &#123;</span><br><span class="line">        MyShiroRealm myShiroRealm = new MyShiroRealm();</span><br><span class="line">        return myShiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  shiro中常见的过滤器 支持Ant风格</span><br><span class="line">#  anon，authcBasic，auchc，user 是认证过滤器。</span><br><span class="line">#  perms，roles，ssl，rest，port 是授权过滤器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* anon---------------org.apache.shiro.web.filter.authc.AnonymousFilter 没有参数，表示可以匿名使用。</span><br><span class="line">* authc--------------org.apache.shiro.web.filter.authc.FormAuthenticationFilter 表示需要认证(登录)才能使用，没有参数</span><br><span class="line">* authcBasic---------org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter 没有参数表示httpBasic认证</span><br><span class="line">* logout-------------org.apache.shiro.web.filter.authc.LogoutFilter</span><br><span class="line">* noSessionCreation--org.apache.shiro.web.filter.session.NoSessionCreationFilter</span><br><span class="line">* perms--------------org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter 参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/**=perms[&quot;user:add:*,user:modify:*&quot;]，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。</span><br><span class="line">* port---------------org.apache.shiro.web.filter.authz.PortFilter port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString是你访问的url里的？后面的参数。</span><br><span class="line">* rest---------------org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter 根据请求的方法，相当于/admins/user/**=perms[user:method] ,其中method为post，get，delete等。</span><br><span class="line">* roles--------------org.apache.shiro.web.filter.authz.RolesAuthorizationFilter 参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，例如admins/user/**=roles[&quot;admin,guest&quot;],每个参数通过才算通过，相当于hasAllRoles()方法。</span><br><span class="line">* ssl----------------org.apache.shiro.web.filter.authz.SslFilter 没有参数，表示安全的url请求，协议为https</span><br><span class="line">* user---------------org.apache.shiro.web.filter.authz.UserFilter 没有参数表示必须存在用户，当登入操作时不做检查</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 编写shiroRealm类</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 继承这个类</span><br><span class="line">public class ShiroRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">	@Resource</span><br><span class="line">	private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    #    // 授权...   获取用户角色和权限</span><br><span class="line">	protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection pc) &#123;</span><br><span class="line">		System.out.println(&quot;shiro 授权管理...&quot;);</span><br><span class="line">		SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</span><br><span class="line">		// 根据当前登录用户 查询对应角色和权限</span><br><span class="line">		Subject subject = SecurityUtils.getSubject();</span><br><span class="line">		User user = (User) subject.getPrincipal();</span><br><span class="line">		// 调用业务层，查询角色</span><br><span class="line">		List&lt;Role&gt; roles = roleService.findByUser(user);</span><br><span class="line">		for (Role role : roles) &#123;</span><br><span class="line">			authorizationInfo.addRole(role.getKeyword());</span><br><span class="line">		&#125;</span><br><span class="line">		// 调用业务层，查询权限</span><br><span class="line">		List&lt;Permission&gt; permissions = permissionService.findByUser(user);</span><br><span class="line">		for (Permission permission : permissions) &#123;</span><br><span class="line">			authorizationInfo.addStringPermission(permission.getKeyword());</span><br><span class="line">		&#125;</span><br><span class="line">		return authorizationInfo;</span><br><span class="line">	&#125;</span><br><span class="line">————————————————</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 登录认证  # 参数的token跟control认证的token相对应</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">		String userName = (String) token.getPrincipal();</span><br><span class="line">		String password = new String((char[]) token.getCredentials());</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;用户&quot; + userName + &quot;认证-----ShiroRealm.doGetAuthenticationInfo&quot;);</span><br><span class="line">		User user = userRepository.findByName(userName);</span><br><span class="line">		if (user == null) &#123;</span><br><span class="line">			throw new UnknownAccountException(&quot;用户名错误！&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">    # 这里存的user可以通过subject来获取</span><br><span class="line">    #当返回用户密码时，securityManager安全管理器，自动比较返回密码和用户输入密码是否一致 如果密码一致 登录成功， 如果密码不一致 报密码错误异常</span><br><span class="line">		SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user, password, getName());</span><br><span class="line">		return info;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li> 编写control</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public String login() &#123;</span><br><span class="line">		// 用户名和密码 都保存在model中</span><br><span class="line">		// 基于shiro实现登录</span><br><span class="line">		Subject subject = SecurityUtils.getSubject();</span><br><span class="line"> </span><br><span class="line">		// 用户名和密码信息</span><br><span class="line">		AuthenticationToken token = new UsernamePasswordToken(</span><br><span class="line">				model.getUsername(), model.getPassword());</span><br><span class="line">		try &#123;</span><br><span class="line">			subject.login(token);</span><br><span class="line">			#// 登录成功将用户信息 保存到 Session</span><br><span class="line">			return SUCCESS;</span><br><span class="line">		&#125; catch (AuthenticationException e) &#123;</span><br><span class="line">			// 登录失败</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return LOGIN;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="三、整合thymleaf"><a href="#三、整合thymleaf" class="headerlink" title="三、整合thymleaf"></a>三、整合thymleaf</h1><p>引入标签库&lt; %@ taglib prefix=”shiro” uri=”<a href="http://shiro.apache.org/tags&quot;">http://shiro.apache.org/tags&quot;</a> %&gt;</p>
<p><img src="https://files.mdnice.com/user/11714/cae9b19d-0e72-4dfd-8b44-120bbdf96ad1.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面一一介绍Shiro的标签： </span><br><span class="line"></span><br><span class="line">#  guest标签 验证当前用户是否为“访客”，即未认证（包含未记住）的用户。</span><br><span class="line"></span><br><span class="line">&lt;shiro:guest&gt;  </span><br><span class="line">Hi there!  Please &lt;a href=&quot;login.jsp&quot;&gt;Login&lt;/a&gt; or &lt;a href=&quot;signup.jsp&quot;&gt;Signup&lt;/a&gt; today!  </span><br><span class="line">&lt;/shiro:guest&gt;</span><br><span class="line"></span><br><span class="line">#  user标签 认证通过或已记住的用户。</span><br><span class="line"></span><br><span class="line">&lt;shiro:user&gt; </span><br><span class="line">    Welcome back John!  Not John? Click &lt;a href=&quot;login.jsp&quot;&gt;here&lt;a&gt; to login.  </span><br><span class="line">&lt;/shiro:user&gt;</span><br><span class="line"></span><br><span class="line">#  authenticated标签 已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。 </span><br><span class="line"></span><br><span class="line">&lt;shiro:authenticated&gt;  </span><br><span class="line">    &lt;a href=&quot;updateAccount.jsp&quot;&gt;Update your contact information&lt;/a&gt;.  </span><br><span class="line">&lt;/shiro:authenticated&gt;</span><br><span class="line"></span><br><span class="line">#  notAuthenticated标签 未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。 </span><br><span class="line"></span><br><span class="line">&lt;shiro:notAuthenticated&gt; </span><br><span class="line">    Please &lt;a href=&quot;login.jsp&quot;&gt;login&lt;/a&gt; in order to update your credit card information.  </span><br><span class="line">&lt;/shiro:notAuthenticated&gt;</span><br><span class="line"></span><br><span class="line">#  principal 标签 输出当前用户信息，通常为登录帐号信息。</span><br><span class="line"></span><br><span class="line">Hello, &lt;shiro:principal/&gt;, how are you today?  </span><br><span class="line"></span><br><span class="line">#  hasRole标签 验证当前用户是否属于该角色。</span><br><span class="line"></span><br><span class="line">&lt;shiro:hasRole name=&quot;administrator&quot;&gt;  </span><br><span class="line">    &lt;a href=&quot;admin.jsp&quot;&gt;Administer the system&lt;/a&gt;  </span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br><span class="line"></span><br><span class="line">#  lacksRole标签 与hasRole标签逻辑相反，当用户不属于该角色时验证通过。</span><br><span class="line"></span><br><span class="line">&lt;shiro:lacksRole name=&quot;administrator&quot;&gt;  </span><br><span class="line">    Sorry, you are not allowed to administer the system.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br><span class="line"></span><br><span class="line">#  hasAnyRole标签 验证当前用户是否属于以下任意一个角色。 </span><br><span class="line">&lt;shiro:hasAnyRoles name=&quot;developer, project manager, administrator&quot;&gt;  </span><br><span class="line">    You are either a developer, project manager, or administrator.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br><span class="line"></span><br><span class="line">#  hasPermission标签 验证当前用户是否拥有指定权限。</span><br><span class="line"></span><br><span class="line">&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  </span><br><span class="line">    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  </span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br><span class="line"></span><br><span class="line">#  lacksPermission标签 与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过。</span><br><span class="line"></span><br><span class="line">&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;  </span><br><span class="line">    &lt;a href=&quot;createUser.jsp&quot;&gt;Create a new User&lt;/a&gt;  </span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure>


<h1 id="Apache-Shiro-权限控制（小结）"><a href="#Apache-Shiro-权限控制（小结）" class="headerlink" title="Apache Shiro 权限控制（小结）"></a>Apache Shiro 权限控制（小结）</h1><p>第一种：URL 级别粗粒度权限控制 配置 web.xml 的 shiroFilter 拦截 /*  在 spring 的 applicationContext*.xml 配置文件中配置同名 bean，配置 filterChainDefinitions 拦截控制规则  </p>
<p>xxx.html* = anon （未登录可以访问）  </p>
<p>xxx.html* =authc （必须登录才能访问 ）  </p>
<p>xxx.html* = perms[权限] （需要特定权限才能访问）</p>
<p> xxx.html* = roles[角色] （需要特定角色才能访问 ） <br> <br>第二种： 方法级别细粒度权限控制  在 spring 的 applicationContext*.xml 配置 spring aop 对 spring 管理 bean 对象开启 shiro 注解支持  </p>
<p>@RequiresPermissions(权限)  需要特定权限才能访问  </p>
<p>@RequiresRoles(角色)  需要特定角色才能访问  </p>
<p>@RequiresAuthentication 需要认证才能访问  <br> <br>第三种：通过 shiro 自定义标签，实现页面元素显示控制  </p>
<p>&lt; shiro:authenticated&gt; 登录后才能访问  </p>
<p>&lt;shiro:hasPermission name=”abc”&gt; 需要特定权限才能访问  </p>
<p>&lt;shiro:hasRole name=”abc”&gt; 需要特定角色才能访问 </p>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda和流</title>
    <url>/2021/07/23/JAVA%E5%9F%BA%E7%A1%80/Lambda%E5%92%8CStream%E6%B5%81/</url>
    <content><![CDATA[<p><strong>函数编程 Lambda和流</strong><br>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为⼀个⽅ 法的参数（函数作为参数传递进⽅法中）。使⽤ Lambda 表达式可以使代码变的更加简洁紧凑。  </p>
<p>函数式接： 必须是 函数式接才可以使⽤lambada 表达示 ，函数式接⼝笼统的讲就是只有⼀个抽像⽅法接⼝就是函数式接⼝，其详细特征如下：  </p>
<ul>
<li>接⼝中标注了 @FunctionalInterface 注解  </li>
<li>接⼝中只有⼀个抽像⽅法 会被编译器⾃动认识成函数式接  </li>
<li>接⼝中有⼀个抽像⽅法，同时包含了Object类的其它抽像⽅法也会被识别成抽像接⼝<span id="more"></span>
<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><h2 id="简单的语法简介"><a href="#简单的语法简介" class="headerlink" title="简单的语法简介"></a>简单的语法简介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//只有一个方法的函数式接口</span><br><span class="line">public interface FunctionInterface &#123;  void excute();	&#125;</span><br><span class="line">//1、使用lamda表达式</span><br><span class="line">NoRetrunNoParam noRetrunNoParam1=()-&gt;&#123;System.out.println(&quot;内部类&quot;);&#125;;</span><br><span class="line">//2、若是有一个参数.可以自动匹配类型</span><br><span class="line">NoRetrunNoParam noRetrunNoParam1=a-&gt;&#123;System.out.println(&quot;内部类&quot;);&#125;;</span><br><span class="line">//3、多个参数，类型可以不写</span><br><span class="line">NoRetrunNoParam noRetrunNoParam1=(a，b)-&gt;&#123;System.out.println(&quot;内部类&quot;);&#125;;</span><br><span class="line">//4、返回值简写</span><br><span class="line">RetrunMultiParam retrunMultiParam = (int a, int b) -&gt; &#123;return a + b;&#125;;</span><br><span class="line">//5、如果只有一句可以执行。如果方法体中只有一行语句，则可以省略方法体大括号&#123;&#125;</span><br><span class="line">NoRetrunNoParam noRetrunNoParam2 = () -&gt; System.out.println(&quot;当实现类方法体中只有一行代码可以省略大括号~OK!&quot;);</span><br><span class="line">//4. 简化方法体大括号。如果方法体只有一条语句，并且是 return 语句，则可省略方法体大括号和 return 关键字</span><br><span class="line">RetrunMultiParam retrunMultiParam1 = (a, b) -&gt; a + b;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="表达式引用方法"><a href="#表达式引用方法" class="headerlink" title="表达式引用方法"></a>表达式引用方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface Interface1 &#123;    int method(int a);&#125;</span><br><span class="line">定义类</span><br><span class="line">public class test&#123;</span><br><span class="line">     //静态方法</span><br><span class="line">    public static int numStatic(int a) &#123;        return a + 1000;    &#125;</span><br><span class="line">    //普通方法</span><br><span class="line">    public int numGeneral(int a) &#123;        return a + 1500;    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  // 将test类的静态方法作为</span><br><span class="line">        Interface1 interface1 = test::numStatic;</span><br><span class="line">        System.out.println(retrunOneParam.method(20));</span><br><span class="line">        </span><br><span class="line">        //讲接口interface1的实现定义为test1对象的num方法</span><br><span class="line">        test test1 = new test();</span><br><span class="line">        Interface1 interface1 = test1::numGeneral;</span><br><span class="line">        System.out.println(retrunOneParam1.method(50));</span><br></pre></td></tr></table></figure>

<h2 id="构造方法的引用"><a href="#构造方法的引用" class="headerlink" title="构造方法的引用"></a>构造方法的引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义无参数接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface ItemCreatorBlackConstruct &#123;    </span><br><span class="line">      Item getItem();//获取item对象</span><br><span class="line">&#125;</span><br><span class="line">//有参数的接口</span><br><span class="line">@FunctionalInterface</span><br><span class="line">interface ItemCreatorParamContruct &#123;</span><br><span class="line">    Item getItem(int id, String name, double price);</span><br><span class="line">&#125;</span><br><span class="line">//Lambda表达式简化</span><br><span class="line">//第一种</span><br><span class="line">ItemCreatorBlackConstruct construct1 = () -&gt; new Item();</span><br><span class="line">Item item1 = construct1.getItem();</span><br><span class="line">//第二种</span><br><span class="line">ItemCreatorBlackConstruct construct1 =Item::new;</span><br><span class="line">Item item1 = construct1.getItem();</span><br><span class="line">//第三种 使用有参</span><br><span class="line">ItemCreatorParamContruct contruct3 = Item::new;</span><br><span class="line">Item item3 = contruct3.getItem(1, &quot;张三&quot;, 12.3);</span><br></pre></td></tr></table></figure>
<h2 id="创建线程对象"><a href="#创建线程对象" class="headerlink" title="创建线程对象"></a>创建线程对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Runnable以前写法</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;OK~!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">// Lambda表达式创建</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;OK~!&quot;);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">// 简化上面Lambda</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;OK~!&quot;)).start();</span><br><span class="line">//线程池</span><br><span class="line">ExecutorService executorService = newCachedThreadPool();</span><br><span class="line">// Runable（无返回值）</span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;OK~!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// Callable（有返回值）</span><br><span class="line">executorService.submit(() -&gt; &#123;</span><br><span class="line">    return &quot;完成了！&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7);</span><br><span class="line"> //Lambda表达式遍历</span><br><span class="line">------------------------------第一种---------------------------------</span><br><span class="line">   list.forEach((t) -&gt; &#123;</span><br><span class="line">            System.out.print(t + &quot;\t&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">------------------------------简化---------------------------------</span><br><span class="line">  list.forEach(t -&gt; System.out.print(t + &quot;\t&quot;));</span><br><span class="line">------------------------------极度简化---------------------------------</span><br><span class="line">  list.forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">----------------------------遍历删除某个元素-------------------------------</span><br><span class="line"> List&lt;Star&gt; stars = new ArrayList&lt;&gt;();</span><br><span class="line">        stars.add(new Star(1, &quot;刘德华&quot;, true));</span><br><span class="line">        stars.add(new Star(2, &quot;郭富城&quot;, true));</span><br><span class="line">        stars.add(new Star(3, &quot;迪丽热巴&quot;, false));</span><br><span class="line">        stars.add(new Star(4, &quot;水菜麗&quot;, false));</span><br><span class="line">        stars.add(new Star(5, &quot;泷泽萝拉&quot;, false));</span><br><span class="line">      </span><br><span class="line"> // 增强for循环 移除元素</span><br><span class="line">        for (Star star : stars) &#123;</span><br><span class="line">            if (star.getId() == 2) &#123;</span><br><span class="line">                stars.remove(star);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">------------------------------Lambda简化---------------------------------</span><br><span class="line">  stars.removeIf((t) -&gt; &#123;            return t.getId() == 3; &#125;);</span><br><span class="line">                          //return简化不写</span><br><span class="line">  stars.removeIf(t -&gt; t.getId() == 5);</span><br><span class="line"> ----------------------------排序所有元素------------------------------- </span><br><span class="line">              // 使用集合工具类，给集合升序排序</span><br><span class="line">        Collections.sort(stars, new Comparator&lt;Star&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Star o1, Star o2) &#123;</span><br><span class="line">                return o1.getId() - o2.getId(); // 升序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">------------------------------Lambda简化---------------------------------</span><br><span class="line">            // 使用Lambda表达式 给集合降序排序</span><br><span class="line">        Collections.sort(stars, (o1, o2) -&gt; &#123;</span><br><span class="line">            return o2.getId() - o1.getId();</span><br><span class="line">        &#125;);</span><br><span class="line">          // 以上代码当然可以简化了，因为方法体只有一条语句，return</span><br><span class="line">        Collections.sort(stars, ((o1, o2) -&gt; o2.getId() - o1.getId()));</span><br><span class="line">        System.out.println(stars);</span><br><span class="line">        // 集合工具类默认是升序排序，所以升序排序的话 还可以简化 </span><br><span class="line">        //方法传参comparingInt（ToIntFunction&lt;? super T&gt; keyExtractor）</span><br><span class="line">        //ToIntFunction&lt;T&gt;有一份方法   int applyAsInt(T value);</span><br><span class="line">        Collections.sort(stars, (Comparator.comparingInt(Star::getId)));</span><br></pre></td></tr></table></figure>
<h1 id="java8之后的Stream流"><a href="#java8之后的Stream流" class="headerlink" title="java8之后的Stream流"></a>java8之后的Stream流</h1><p>Stream 流处理，首先要澄清的是 java8 中的 Stream 与 I/O 流 InpuStream 和 OutputStream 是完全不同的概念。Stream 机制是针对集合迭代器的增强。流允许你用声明式的方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。流的出现是应对分布式系统下，存储数据不再是局限于数据库  </p>
<h2 id="流的操作特性"><a href="#流的操作特性" class="headerlink" title="流的操作特性"></a>流的操作特性</h2><ol>
<li>stream不存储数据 </li>
<li>stream不改变源数据 </li>
<li>stream 不可重复使⽤</li>
</ol>
<h2 id="流的操作类型"><a href="#流的操作类型" class="headerlink" title="流的操作类型"></a>流的操作类型</h2><p>stream 所有操作组合在⼀起即变成了管道，管道中有以下两种操作： </p>
<ul>
<li> 中间操作(intermediate /,ɪntə’miːdɪət/): 调⽤中间操作⽅法会返回⼀个新的流。通过连续执⾏多个操作倒便就组成了Stream中的执⾏管道（pipeline）。需要注意的是这些管道被添 加后并不会真正执⾏，只有等到调⽤终值操作之后才会执⾏。 </li>
<li>终值操作(terminal /‘tɜːmɪn(ə)l/)： 在调⽤该⽅法后，将执⾏之前所有的中间操作，获返回结果结束对流的使⽤  </li>
</ul>
<p><strong>流的执⾏顺序：其每个元素挨着作为参数去调⽤中间操作及终值操作，⽽不是遍历完⼀个⽅法，在遍历下⼀个⽅法。</strong></p>
<h2 id="流的并形操作"><a href="#流的并形操作" class="headerlink" title="流的并形操作"></a>流的并形操作</h2><p>调⽤Stream.parallel（）⽅法可以将流基于多个线程并⾏执⾏</p>
<h2 id="创建流的方式"><a href="#创建流的方式" class="headerlink" title="创建流的方式"></a>创建流的方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种:由集合对象创建流。对支持流处理的对象调用 stream()。支持流处理的对象包括 Collection 集合及其子类</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(1,2,3);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">//第二种：由数组创建流。通过静态方法 Arrays.stream() 将数组转化为流（Stream）</span><br><span class="line">IntStream stream = Arrays.stream(new int[]&#123;3, 2, 1&#125;);</span><br><span class="line"></span><br><span class="line">//第三种通过静态方法 Stream.of() ，但是底层其实还是调用 Arrays.stream()</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3);</span><br><span class="line"></span><br><span class="line">-  Collection#stream </span><br><span class="line">-  Arrays#stream </span><br><span class="line">-  Stream#Stream </span><br><span class="line">-  Stream#generate</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##  Stream 中的常⽤API及场景</span><br><span class="line">filter 接收⼀个Boolean表达示来过滤元素 #中间操作</span><br><span class="line">map 将流中元素 1:1 映谢成另外⼀个元素 #中间操作</span><br><span class="line">mapToInt 将流中元素映谢成int，mapToLong、 mapToDouble操作类似⽬的减少装箱拆箱带来的损耗 #中间操作</span><br><span class="line">flatMap 如map时返回的是⼀个List, 将会进⼀步拆分。详⻅ flatMap示例 中间操作 forEach 遍历流中所有元素 #终值操作 </span><br><span class="line">sorted 排序 中间操作 peek 遍历流中所有元素 ，如forEach不同在于不会结束流 #中间操作 </span><br><span class="line">toArray 将流中元素转换成⼀个数组返回 终值操作 reduce 归约合并操作 #中间操作 </span><br><span class="line">collect 采集数据，返回⼀个新的结果 参数说明： Supplier&lt;R&gt;： 采集需要返回的结果 BiConsumer&lt;R, ? super T&gt;：传递结果与元素进⾏合并。 BiConsumer&lt;R, R&gt;：在并发执⾏的时候结果合并操作。详⻅ collec示例 #终值操作 </span><br><span class="line">distinct 基于equal 表达示去重 中间操作 max 通过⽐较函数 返回最⼤值 #终值操作 </span><br><span class="line">anyMatch 流中是否有任⼀元素满⾜表达示 终值操作 allMatch 流中所有元素满⾜表达示返回true #终值操作 </span><br><span class="line">noneMatch 与allMatch 相反，都不满⾜的情况下返回 true 终值操作 findFirst 找出流中第⼀个元素 #终值操作 </span><br><span class="line">of ⽣成流 ⽣成流操作 iterate 基于迭代⽣成流 #⽣成流操作 </span><br><span class="line">generate 基于迭代⽣成流，与iterate 不同的是不 后⼀元素的 ⽣成，不依懒前⼀元素 #⽣成流操作 </span><br><span class="line">concat 合并两个相同类型的类 #⽣成流操作</span><br><span class="line"></span><br><span class="line">##  Collectors 中的常⽤API及场景</span><br><span class="line">toList 转换成list</span><br><span class="line">toMap 转换成map </span><br><span class="line">groupingBy 统计分组 </span><br><span class="line">averagingInt 求平均值 </span><br><span class="line">summingInt 求总值 </span><br><span class="line">maxBy 获取最⼤值</span><br></pre></td></tr></table></figure>
<h2 id="流的关闭机制"><a href="#流的关闭机制" class="headerlink" title="流的关闭机制"></a>流的关闭机制</h2><p>⼀般情况使⽤完流之后不需要调⽤close ⽅法进⾏关闭，除⾮是使⽤channel FileInputStream 这类的操作需要关闭,可调⽤ java.util.stream.BaseStream#onClose() 添加关闭监听.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">空流：Stream.empty()</span><br><span class="line">无限流：Stream.generate() 和 Stream.iterate()。可以配合 limit() 使用可以限制一下数量</span><br><span class="line">// 接受一个 Supplier 作为参数</span><br><span class="line">Stream.generate(Math::random).limit(10).forEach(System.out::println);</span><br><span class="line">// 初始值是 0，新值是前一个元素值 + 2</span><br><span class="line">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus的快速启动</title>
    <url>/2021/07/23/Spring/mybatis-plus%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window) 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。<a href="https://mybatis.plus/guide/">MyBatis-Plus官网</a></p>
<span id="more"></span>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a>初始化工程</h3><ul>
<li> log4j.properties </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局日志配置 </span><br><span class="line">log4j.rootLogger=INFO, stdout </span><br><span class="line"># MyBatis 日志配置 </span><br><span class="line">log4j.logger.cn.tulingxueyuan=truce </span><br><span class="line"># 控制台输出 </span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] ‐ %m%n</span><br></pre></td></tr></table></figure>

<p>添加依赖 mybatis-plus-boot-starter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data  创建user表</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建mapper 继承BaseMapper&lt;User&gt; 自动生成CRUD操作</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结果测试</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SampleTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelect() &#123;</span><br><span class="line">        System.out.println((&quot;----- selectAll method test ------&quot;));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(null);</span><br><span class="line">        Assert.assertEquals(5, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatis-plus的核心功能"><a href="#mybatis-plus的核心功能" class="headerlink" title="mybatis-plus的核心功能"></a>mybatis-plus的核心功能</h2><h3 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h3><ul>
<li> 使用 Wrapper 自定义SQL</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val queryWrapper = KtQueryWrapper(User()).eq(User::name, &quot;sss&quot;).eq(User::roleId, &quot;sss2&quot;)</span><br><span class="line">userMapper!!.selectList(queryWrapper)</span><br><span class="line"></span><br><span class="line">val updateConditionWrapper = KtUpdateWrapper(User()).eq(User::name, &quot;sss&quot;).eq(User::roleId, &quot;sss2&quot;)</span><br><span class="line">val updateRecord = User()</span><br><span class="line">updateRecord.name = &quot;newName&quot;</span><br><span class="line">userMapper!!.update(updateRecord, updateConditionWrapper)</span><br><span class="line"></span><br><span class="line">val updateRecord = User()</span><br><span class="line">updateRecord.id = 2</span><br><span class="line">updateRecord.name = &quot;haha&quot;</span><br><span class="line">userMapper.updateById(updateRecord)</span><br></pre></td></tr></table></figure>

<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Spring boot方式</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.baomidou.cloud.service.*.mapper*&quot;)</span><br><span class="line">public class MybatisPlusConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 旧版</span><br><span class="line">    @Bean</span><br><span class="line">    public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();</span><br><span class="line">        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false</span><br><span class="line">        // paginationInterceptor.setOverflow(false);</span><br><span class="line">        // 设置最大单页限制数量，默认 500 条，-1 不受限制</span><br><span class="line">        // paginationInterceptor.setLimit(500);</span><br><span class="line">        // 开启 count 的 join 优化,只针对部分 left join</span><br><span class="line">        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));</span><br><span class="line">        return paginationInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 最新版</span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sequence主键策略"><a href="#Sequence主键策略" class="headerlink" title="Sequence主键策略"></a>Sequence主键策略</h3><ul>
<li> 主键生成策略</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主键生成策略必须使用INPUT</span><br><span class="line">支持父类定义@KeySequence子类继承使用</span><br><span class="line">支持主键类型指定(3.3.0开始自动识别主键类型)</span><br><span class="line">内置支持：</span><br><span class="line">DB2KeyGenerator</span><br><span class="line">H2KeyGenerator</span><br><span class="line">KingbaseKeyGenerator</span><br><span class="line">OracleKeyGenerator</span><br><span class="line">PostgreKeyGenerator</span><br><span class="line">如果内置支持不满足你的需求，可实现IKeyGenerator接口来进行扩展.</span><br><span class="line"></span><br><span class="line">@KeySequence(value = &quot;SEQ_ORACLE_STRING_KEY&quot;, clazz = String.class)</span><br><span class="line">public class YourEntity &#123;</span><br><span class="line">    </span><br><span class="line">    @TableId(value = &quot;ID_STR&quot;, type = IdType.INPUT)</span><br><span class="line">    private String idStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用的配置</strong></p>
<ul>
<li> springBoot的配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种方式</span><br><span class="line">      @Bean</span><br><span class="line">      public IKeyGenerator keyGenerator() &#123;</span><br><span class="line">          return new H2KeyGenerator();</span><br><span class="line">      &#125;</span><br><span class="line">//第二种方式</span><br><span class="line">@Bean</span><br><span class="line">public MybatisPlusPropertiesCustomizer plusPropertiesCustomizer() &#123;</span><br><span class="line">    return plusProperties -&gt; plusProperties.getGlobalConfig().getDbConfig().setKeyGenerator(new H2KeyGenerator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义ID生成器"><a href="#自定义ID生成器" class="headerlink" title="自定义ID生成器"></a>自定义ID生成器</h3><p>自3.3.0开始,默认使用雪花算法+UUID(不含中划线)</p>
<ul>
<li> Springboot方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一种： 声明bean供spring扫描注入</span><br><span class="line">@Component</span><br><span class="line">public class CustomIdGenerator implements IdentifierGenerator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Long nextId(Object entity) &#123;</span><br><span class="line">      	//可以将当前传入的class全类名来作为bizKey,或者提取参数来生成bizKey进行分布式Id调用生成.</span><br><span class="line">      	String bizKey = entity.getClass().getName();</span><br><span class="line">        //根据bizKey调用分布式ID生成</span><br><span class="line">        long id = ....;</span><br><span class="line">      	//返回生成的id值即可.</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//第二种  使用配置类</span><br><span class="line">@Bean</span><br><span class="line">public IdentifierGenerator idGenerator() &#123;</span><br><span class="line">    return new CustomIdGenerator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三种 通过MybatisPlusPropertiesCustomizer自定义</span><br><span class="line">@Bean</span><br><span class="line">public MybatisPlusPropertiesCustomizer plusPropertiesCustomizer() &#123;</span><br><span class="line">    return plusProperties -&gt; plusProperties.getGlobalConfig().setIdentifierGenerator(new CustomIdGenerator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="mybatis-plus扩展–插件"><a href="#mybatis-plus扩展–插件" class="headerlink" title="mybatis-plus扩展–插件"></a>mybatis-plus扩展–插件</h2><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><ul>
<li> 说明<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">填充原理是直接给entity的属性设置值!!!</span><br><span class="line">注解则是指定该属性在对应情况下必有值,如果无值则入库会是null</span><br><span class="line">MetaObjectHandler提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为null则不填充</span><br><span class="line">字段必须声明TableField注解,属性fill选择对应策略,该声明告知Mybatis-Plus需要预留注入SQL字段</span><br><span class="line">填充处理器MyMetaObjectHandler在 Spring Boot 中需要声明@Component或@Bean注入</span><br><span class="line">要想根据注解FieldFill.xxx和字段名以及字段类型来区分必须使用父类的strictInsertFill或者strictUpdateFill方法</span><br><span class="line">不需要根据任何来区分可以使用父类的fillStrategy方法</span><br></pre></td></tr></table></figure></li>
<li> 步骤1：配置application.yml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: flag  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值(默认为 1)</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li> 步骤2：实体类字段上加上@TableLogic的注解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@TableLogic</span><br><span class="line">private Integer deleted;</span><br></pre></td></tr></table></figure>
<ul>
<li> 开启测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  如何insert </span><br><span class="line">          字段在数据库定义默认值(推荐)</span><br><span class="line">          insert 前自己 set 值</span><br><span class="line">          使用自动填充功能</span><br><span class="line"></span><br><span class="line">//  删除接口自动填充功能失效</span><br><span class="line">使用 update 方法并: UpdateWrapper.set(column, value)(推荐)</span><br><span class="line">使用 update 方法并: UpdateWrapper.setSql(&quot;column=value&quot;)</span><br><span class="line">使用Sql注入器注入com.baomidou.mybatisplus.extension.injector.methods.LogicDeleteByIdWithFill并使用(推荐)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><p>实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler<br>注解填充字段 @TableField(.. fill = FieldFill.INSERT) 生成器策略部分也可以配置</p>
<ul>
<li><p> pojo中给需要自动填充的字段中添加标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    // 注意！这里需要标记为填充字段</span><br><span class="line">    @TableField(.. fill = FieldFill.INSERT)</span><br><span class="line">    private String fillField;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 然后自定义实现拦截器类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MyMetaObjectHandler implements MetaObjectHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void insertFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start insert fill ....&quot;);</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐使用)</span><br><span class="line">        // 或者</span><br><span class="line">        this.strictInsertFill(metaObject, &quot;createTime&quot;, () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐)</span><br><span class="line">        // 或者</span><br><span class="line">        this.fillStrategy(metaObject, &quot;createTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateFill(MetaObject metaObject) &#123;</span><br><span class="line">        log.info(&quot;start update fill ....&quot;);</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); // 起始版本 3.3.0(推荐)</span><br><span class="line">        // 或者</span><br><span class="line">        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, () -&gt; LocalDateTime.now(), LocalDateTime.class); // 起始版本 3.3.3(推荐)</span><br><span class="line">        // 或者</span><br><span class="line">        this.fillStrategy(metaObject, &quot;updateTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充原理是直接给entity的属性设置值!!!<br>注解则是指定该属性在对应情况下必有值,如果无值则入库会是null<br>MetaObjectHandler提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为null则不填充<br>字段必须声明TableField注解,属性fill选择对应策略,该声明告知Mybatis-Plus需要预留注入SQL字段<br>填充处理器MyMetaObjectHandler在 Spring Boot 中需要声明@Component或@Bean注入<br>要想根据注解FieldFill.xxx和字段名以及字段类型来区分必须使用父类的strictInsertFill或者strictUpdateFill方法<br>不需要根据任何来区分可以使用父类的fillStrategy方法</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的实现方式：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在数据库中添加version字段</span><br><span class="line">          ·  取出记录时，获取当前version  </span><br><span class="line">          ·  更新时，带上这个version  </span><br><span class="line">          ·  执行更新时， set version = newVersion where version = oldVersion  </span><br><span class="line">          ·  如果version不对，就更新失败  </span><br></pre></td></tr></table></figure>
<p><strong>快速使用</strong></p>
<ul>
<li> 1.配置插件<br>spring xml方式:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor&quot; id=&quot;optimisticLockerInnerInterceptor&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;mybatisPlusInterceptor&quot; class=&quot;com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;interceptors&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean=&quot;optimisticLockerInnerInterceptor&quot;/&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>spring boot注解方式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;</span><br><span class="line">    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span><br><span class="line">    return interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 2.在实体类的字段上加上@Version注解</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Version</span><br><span class="line">private Integer version;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime<br>整数类型下 newVersion = oldVersion + 1  newVersion 会回写到 entity 中<br><strong>仅支持 updateById(id) 与 update(entity, wrapper) 方法</strong><br>在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</p>
]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的定时任务和事件</title>
    <url>/2021/07/23/Spring/Spring%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<p>定时任务在配置类上添加@EnableScheduling开启对定时任务的支持，在相应的方法上添加@Scheduled声明需要执行的定时任务。<br>使用spring事件机制能很好地帮助我们消除不同业务间的耦合关系,也可以提高执行效率,应该根据业务场景灵活选择.</p>
<span id="more"></span>
<h2 id="定时任务的快速使用"><a href="#定时任务的快速使用" class="headerlink" title="定时任务的快速使用"></a>定时任务的快速使用</h2><ul>
<li> 第一步：在启动类上添加@EnableScheduling注解 开启对定时任务的支持</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBootApplication</span><br><span class="line">@EnableScheduling //开启定时任务</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 第二部：在相应的方法上添加@Schedule声明定时任务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Schedule的使用规则</span><br><span class="line">fixedRate和fixedDelay，单位是毫秒，这里这里就是5秒和3秒，它们的区别就是：</span><br><span class="line">fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，我们会选择不同的方式。</span><br><span class="line">cron表达式：比如你要设置每天什么时候执行，就可以用它特殊的语法可以单独去查。简单的语法。cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：秒、分、时、天、月、星期、年份</span><br><span class="line">initialDelay 和initialDelayString表示一个初始延迟时间，第一次被调用前延迟的时间</span><br><span class="line"></span><br><span class="line">cron中的特殊符号：</span><br><span class="line">(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...</span><br><span class="line">(?)问号：问号只能出现在日期和星期这两个位置。</span><br><span class="line">(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12</span><br><span class="line">(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四</span><br><span class="line">(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Jobs &#123;</span><br><span class="line">    //表示方法执行完成后5秒</span><br><span class="line">    @Scheduled(fixedDelay = 5000)</span><br><span class="line">    public void fixedDelayJob() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;fixedDelay 每隔5秒&quot; + new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示每隔3秒</span><br><span class="line">    @Scheduled(fixedRate = 3000)</span><br><span class="line">    public void fixedRateJob() &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;fixedRate 每隔3秒&quot; + new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示每天8时30分0秒执行</span><br><span class="line">    @Scheduled(cron = &quot;0 0,30 0,8 ? * ? &quot;)</span><br><span class="line">    public void cronJob() &#123;</span><br><span class="line">        System.out.println(new Date() + &quot; ...&gt;&gt;cron....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="spring的事件监听"><a href="#spring的事件监听" class="headerlink" title="spring的事件监听"></a>spring的事件监听</h2><p>spring事件发送监听涉及3个部分<br>ApplicationEvent：表示事件本身，自定义事件需要继承该类,可以用来传递数据,比如上述操作,我们需要将用户的邮箱地址传给事件监听器.<br>ApplicationEventPublisherAware：事件发送器,通过实现这个接口,来触发事件.<br>ApplicationListener：事件监听器接口,事件的业务逻辑封装在监听器里面.</p>
<h3 id="开始监听事件"><a href="#开始监听事件" class="headerlink" title="开始监听事件"></a>开始监听事件</h3><ul>
<li>继承ApplicationEvent类 ，声明一个事件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class OrderSuccessEvent extends ApplicationEvent &#123;    </span><br><span class="line">    public OrderSuccessEvent(Object source) &#123;</span><br><span class="line">        super(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 自定义一个服务类继承ApplicationListener&lt; OrderSuccessEvent&gt;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当ApplicationContext发布事件后OrderSuccessEvent,监听执行</span><br><span class="line">@Service  </span><br><span class="line">@Order(4)  //排序</span><br><span class="line">public class SmsService implements ApplicationListener&lt;OrderSuccessEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(OrderSuccessEvent event) &#123;</span><br><span class="line">        System.out.println(&quot;发送短信...&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li> 发布事件 通过ApplicationContext发布</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class OrderService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public void order() &#123;</span><br><span class="line">        // 下单成功</span><br><span class="line">        System.out.println(&quot;下单成功...&quot;);</span><br><span class="line">        // 发布OrderSuccessEvent通知</span><br><span class="line">        applicationContext.publishEvent(new OrderSuccessEvent(this));</span><br><span class="line">        System.out.println(&quot;main线程结束...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br>下单成功…<br>发送短信…<br>main线程结束…  </p>
<h3 id="扩展一个监听事件"><a href="#扩展一个监听事件" class="headerlink" title="扩展一个监听事件"></a>扩展一个监听事件</h3><p>当我们想要扩展上面的接口的时候就可以，再写一个服务类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service </span><br><span class="line">@Order(1)</span><br><span class="line">public class CarService  implements ApplicationListener&lt;OrderSuccessEvent&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(OrderSuccessEvent event) &#123;</span><br><span class="line">        this.dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    public void dispatch() &#123;</span><br><span class="line">        System.out.println(&quot;发车咯...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：<br>下单成功…<br>发车了…<br>发送短信…<br>main线程结束…  </p>
<h3 id="监听事件的同步和非同步"><a href="#监听事件的同步和非同步" class="headerlink" title="监听事件的同步和非同步"></a>监听事件的同步和非同步</h3><p>//当SimpleApplicationEventMulticaster中的Executor不为null，就会执行异步通知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AsyncEventConfig &#123;</span><br><span class="line">    @Bean(name = &quot;applicationEventMulticaster&quot;)</span><br><span class="line">    public ApplicationEventMulticaster simpleApplicationEventMulticaster() &#123;</span><br><span class="line">        SimpleApplicationEventMulticaster eventMulticaster</span><br><span class="line">                = new SimpleApplicationEventMulticaster();</span><br><span class="line">        eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());</span><br><span class="line">        return eventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>底层源码:<code>SimpleApplicationEventMulticaster中的multicastEventf方法</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType) &#123;</span><br><span class="line">       ResolvableType type = eventType != null ? eventType : this.resolveDefaultEventType(event);</span><br><span class="line">       Executor executor = this.getTaskExecutor();</span><br><span class="line">       Iterator var5 = this.getApplicationListeners(event, type).iterator();</span><br><span class="line"></span><br><span class="line">       while(var5.hasNext()) &#123;</span><br><span class="line">           ApplicationListener&lt;?&gt; listener = (ApplicationListener)var5.next();</span><br><span class="line">           if (executor != null) &#123;       //executor为空执行同步</span><br><span class="line">               executor.execute(() -&gt; &#123;</span><br><span class="line">                   this.invokeListener(listener, event);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125; else &#123;                      //补位空执行异步操作</span><br><span class="line">               this.invokeListener(listener, event);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>spring的学习</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus的逆向工程</title>
    <url>/2021/07/23/Spring/mybatis-plus%E7%9A%84%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Mybatis-plus逆向工程动态的生成pojo、mapper、service、control等</strong>  </p>
<h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span><br><span class="line">public class CodeGenerator &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 读取控制台内容</span><br><span class="line">     * &lt;/p&gt;</span><br><span class="line">     */</span><br><span class="line">    public static String scanner(String tip) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        StringBuilder help = new StringBuilder();</span><br><span class="line">        help.append(&quot;请输入&quot; + tip + &quot;：&quot;);</span><br><span class="line">        System.out.println(help.toString());</span><br><span class="line">        if (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            if (StringUtils.isNotBlank(ipt)) &#123;</span><br><span class="line">                return ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 代码生成器</span><br><span class="line">        AutoGenerator mpg = new AutoGenerator();</span><br><span class="line"></span><br><span class="line">        // 全局配置</span><br><span class="line">        GlobalConfig gc = new GlobalConfig();</span><br><span class="line">        String projectPath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">        gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);</span><br><span class="line">        gc.setAuthor(&quot;jobob&quot;);</span><br><span class="line">        gc.setOpen(false);</span><br><span class="line">        // gc.setSwagger2(true); 实体属性 Swagger2 注解</span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        // 数据源配置</span><br><span class="line">        DataSourceConfig dsc = new DataSourceConfig();</span><br><span class="line">        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/ant?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;);</span><br><span class="line">        // dsc.setSchemaName(&quot;public&quot;);</span><br><span class="line">        dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        dsc.setUsername(&quot;root&quot;);</span><br><span class="line">        dsc.setPassword(&quot;密码&quot;);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        // 包配置</span><br><span class="line">        PackageConfig pc = new PackageConfig();</span><br><span class="line">        pc.setModuleName(scanner(&quot;模块名&quot;));</span><br><span class="line">        pc.setParent(&quot;com.baomidou.ant&quot;);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        // 自定义配置</span><br><span class="line">        InjectionConfig cfg = new InjectionConfig() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void initMap() &#123;</span><br><span class="line">                // to do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 如果模板引擎是 freemarker</span><br><span class="line">        String templatePath = &quot;/templates/mapper.xml.ftl&quot;;</span><br><span class="line">        // 如果模板引擎是 velocity</span><br><span class="line">        // String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><span class="line"></span><br><span class="line">        // 自定义输出配置</span><br><span class="line">        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();</span><br><span class="line">        // 自定义配置会被优先输出</span><br><span class="line">        focList.add(new FileOutConfig(templatePath) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String outputFile(TableInfo tableInfo) &#123;</span><br><span class="line">                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br><span class="line">                return projectPath + &quot;/src/main/resources/mapper/&quot; + pc.getModuleName()</span><br><span class="line">                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        /*</span><br><span class="line">        cfg.setFileCreate(new IFileCreate() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span><br><span class="line">                // 判断自定义文件夹是否需要创建</span><br><span class="line">                checkDir(&quot;调用默认方法创建的目录，自定义目录用&quot;);</span><br><span class="line">                if (fileType == FileType.MAPPER) &#123;</span><br><span class="line">                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false</span><br><span class="line">                    return !new File(filePath).exists();</span><br><span class="line">                &#125;</span><br><span class="line">                // 允许生成模板文件</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        */</span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        mpg.setCfg(cfg);</span><br><span class="line"></span><br><span class="line">        // 配置模板</span><br><span class="line">        TemplateConfig templateConfig = new TemplateConfig();</span><br><span class="line"></span><br><span class="line">        // 配置自定义输出模板</span><br><span class="line">        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span><br><span class="line">        // templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span><br><span class="line">        // templateConfig.setService();</span><br><span class="line">        // templateConfig.setController();</span><br><span class="line"></span><br><span class="line">        templateConfig.setXml(null);</span><br><span class="line">        mpg.setTemplate(templateConfig);</span><br><span class="line"></span><br><span class="line">        // 策略配置</span><br><span class="line">        StrategyConfig strategy = new StrategyConfig();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">        strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span><br><span class="line">        strategy.setEntityLombokModel(true);</span><br><span class="line">        strategy.setRestControllerStyle(true);</span><br><span class="line">        // 公共父类</span><br><span class="line">        strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span><br><span class="line">        // 写于父类中的公共字段</span><br><span class="line">        strategy.setSuperEntityColumns(&quot;id&quot;);</span><br><span class="line">        strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));</span><br><span class="line">        strategy.setControllerMappingHyphenStyle(true);</span><br><span class="line">        strategy.setTablePrefix(pc.getModuleName() + &quot;_&quot;);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line">        mpg.setTemplateEngine(new FreemarkerTemplateEngine());</span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步：引入mybatis‐generator‐core的maven依赖</span><br><span class="line">第二部：写xml文件</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration PUBLIC</span><br><span class="line">        &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--如果需要使用 command的方式生成需要配置数据库驱动的jar包路径</span><br><span class="line">    &lt;classPathEntry location=&quot;指定数据驱动的磁盘路径&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--context 生成上下文 配置生成规则</span><br><span class="line">            id 随意写</span><br><span class="line">           targetRuntime 生成策略</span><br><span class="line">                MyBatis3DynamicSql 默认的，会生成 动态生成sql的方式（没有xml)</span><br><span class="line">                MyBatis3 生成通用的查询，可以指定动态where条件</span><br><span class="line">                MyBatis3Simple 只生成简单的CRUD</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;!--设置是否生成注释  true 不生成  注意： 如果不生成注释，下次生成代码就不会进行合并--&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line">        &lt;!--数据源 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span><br><span class="line">                        userId=&quot;root&quot;</span><br><span class="line">                        password=&quot;123456&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--pojo</span><br><span class="line">        javaModelGenerator  java实体生成规则(POJO)</span><br><span class="line">            targetPackage 生成到哪个包下</span><br><span class="line">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;cn.tulingxueyuan.pojo&quot; targetProject=&quot;src/main/java&quot;/&gt;</span><br><span class="line">        &lt;!--mapper xml映射文件</span><br><span class="line">            sqlMapGenerator mapper xml映射文件生成规则</span><br><span class="line">            targetPackage 生成到哪个包下</span><br><span class="line">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;cn.tulingxueyuan.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;&lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!--mapper接口</span><br><span class="line">            javaClientGenerator mapper mapper接口生成规则</span><br><span class="line">            type 指定生成的方式</span><br><span class="line">                1.使用注解的方式生成</span><br><span class="line">                2.使用接口绑定的方式生成（要配置sqlMapGenerator）</span><br><span class="line">            targetPackage 生成到哪个包下</span><br><span class="line">            targetProject 生成到当前文件的哪个相对路径下--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;cn.tulingxueyuan.mapper&quot; targetProject=&quot;src/main/java&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!--配置哪些表需要进行代码生成</span><br><span class="line">        tableName 表名</span><br><span class="line">        domainObjectName pojo类名</span><br><span class="line">        mapperName 对应mapper接口的类名 和 mapper xml文件名</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;table tableName=&quot;emp&quot; domainObjectName=&quot;Emp&quot; mapperName=&quot;EmpMapper&quot; /&gt;</span><br><span class="line">        &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot; mapperName=&quot;DeptMapper&quot; /&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure>
<p><strong>执行代码块</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test01() throws Exception &#123;</span><br><span class="line">        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();</span><br><span class="line">        boolean overwrite = true;</span><br><span class="line">        File configFile = new File(&quot;generatorConfig.xml&quot;);</span><br><span class="line">        ConfigurationParser cp = new ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = new DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Date JPA</title>
    <url>/2021/07/23/Spring/Spring%20Date%20JPA%20/</url>
    <content><![CDATA[<h1 id="JPA-描述"><a href="#JPA-描述" class="headerlink" title="JPA 描述"></a>JPA 描述</h1><p>JPA是一种规范，没有具体的实现，可以更佳简便的编程</p>
<span id="more"></span>

<h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @Id：声明主键的配置</span><br><span class="line">     * @GeneratedValue:配置主键的生成策略</span><br><span class="line">     *      strategy</span><br><span class="line">     *          GenerationType.IDENTITY ：自增，mysql</span><br><span class="line">     *                 * 底层数据库必须支持自动增长（底层数据库支持的自动增长方式，对id自增）</span><br><span class="line">     *          GenerationType.SEQUENCE : 序列，oracle</span><br><span class="line">     *                  * 底层数据库必须支持序列</span><br><span class="line">     *          GenerationType.TABLE : jpa提供的一种机制，通过一张数据库表的形式帮助我们完成主键自增</span><br><span class="line">     *          GenerationType.AUTO ： 由程序自动的帮助我们选择主键生成策略</span><br><span class="line">     * @Column:配置属性和字段的映射关系</span><br><span class="line">     *      name：数据库表中字段的名称</span><br><span class="line">     */</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;cust_id&quot;)</span><br><span class="line">    private Long custId; //客户的主键</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">@Entity</span><br><span class="line">        	作用：指定当前类是实体类。</span><br><span class="line">        @Table</span><br><span class="line">        	作用：指定实体类和表之间的对应关系。</span><br><span class="line">        	属性：</span><br><span class="line">        		name：指定数据库表的名称</span><br><span class="line">        @Id</span><br><span class="line">        	作用：指定当前字段是主键。</span><br><span class="line">        @GeneratedValue</span><br><span class="line">        	作用：指定主键的生成方式。。</span><br><span class="line">        	属性：</span><br><span class="line">        		strategy ：指定主键生成策略。</span><br><span class="line">        @Column</span><br><span class="line">        	作用：指定实体类属性和数据库表之间的对应关系</span><br><span class="line">        	属性：</span><br><span class="line">        		name：指定数据库表的列名称。</span><br><span class="line">        		unique：是否唯一  </span><br><span class="line">        		nullable：是否可以为空  </span><br><span class="line">        		inserttable：是否可以插入  </span><br><span class="line">        		updateable：是否可以更新  </span><br><span class="line">        		columnDefinition: 定义建表时创建此列的DDL  </span><br><span class="line">        		secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境[重点]</span><br><span class="line">            </span><br><span class="line">@OneToMany:</span><br><span class="line">   	作用：建立一对多的关系映射</span><br><span class="line">    属性：</span><br><span class="line">    	targetEntityClass：指定多的多方的类的字节码</span><br><span class="line">    	mappedBy：指定从表实体类中引用主表对象的名称。</span><br><span class="line">    	cascade：指定要使用的级联操作</span><br><span class="line">    	fetch：指定是否采用延迟加载</span><br><span class="line">    	orphanRemoval：是否使用孤儿删除</span><br><span class="line"></span><br><span class="line">@ManyToOne</span><br><span class="line">    作用：建立多对一的关系</span><br><span class="line">    属性：</span><br><span class="line">    	targetEntityClass：指定一的一方实体类字节码</span><br><span class="line">    	cascade：指定要使用的级联操作</span><br><span class="line">    	fetch：指定是否采用延迟加载</span><br><span class="line">    	optional：关联是否可选。如果设置为false，则必须始终存在非空关系。</span><br><span class="line"></span><br><span class="line">@JoinColumn</span><br><span class="line"> 作用：用于定义主键字段和外键字段的对应关系。</span><br><span class="line">     属性：</span><br><span class="line">    	name：指定外键字段的名称</span><br><span class="line">    	referencedColumnName：指定引用主表的主键字段名称</span><br><span class="line">    	unique：是否唯一。默认值不唯一</span><br><span class="line">    	nullable：是否允许为空。默认值允许。</span><br><span class="line">    	insertable：是否允许插入。默认值允许。</span><br><span class="line">    	updatable：是否允许更新。默认值允许。</span><br><span class="line">    	columnDefinition：列的定义信息。</span><br><span class="line">@ManyToMany</span><br><span class="line">	作用：用于映射多对多关系</span><br><span class="line">	属性：</span><br><span class="line">		cascade：配置级联操作。</span><br><span class="line">		fetch：配置是否采用延迟加载。</span><br><span class="line">    	targetEntity：配置目标的实体类。映射多对多的时候不用写。</span><br><span class="line"></span><br><span class="line">@JoinTable</span><br><span class="line">    作用：针对中间表的配置</span><br><span class="line">    属性：</span><br><span class="line">    	nam：配置中间表的名称</span><br><span class="line">    	joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段			  			</span><br><span class="line">    	inverseJoinColumn：中间表的外键字段关联对方表的主键字段</span><br><span class="line">    	</span><br><span class="line">@JoinColumn</span><br><span class="line">    作用：用于定义主键字段和外键字段的对应关系。</span><br><span class="line">    属性：</span><br><span class="line">    	name：指定外键字段的名称</span><br><span class="line">    	referencedColumnName：指定引用主表的主键字段名称</span><br><span class="line">    	unique：是否唯一。默认值不唯一</span><br><span class="line">      nullable：是否允许为空。默认值允许。</span><br><span class="line">    	insertable：是否允许插入。默认值允许。</span><br><span class="line">    	updatable：是否允许更新。默认值允许。</span><br><span class="line">    	columnDefinition：列的定义信息。</span><br></pre></td></tr></table></figure>

<h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;persistence xmlns=&quot;http://java.sun.com/xml/ns/persistence&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/persistence  </span><br><span class="line">    http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;	version=&quot;2.0&quot;&gt;</span><br><span class="line">&lt;!--配置持久化单元 name：持久化单元名称 transaction-type：事务类型	RESOURCE_LOCAL：本地事务管理	JTA：分布式事务管理 --&gt;</span><br><span class="line">	&lt;persistence-unit name=&quot;myJpa&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;</span><br><span class="line">		&lt;!--配置JPA规范的服务提供商 --&gt;</span><br><span class="line">		&lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;</span><br><span class="line">		&lt;properties&gt;</span><br><span class="line">			&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">			&lt;property name=&quot;javax.persistence.jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">			&lt;!-- 数据库地址 --&gt;</span><br><span class="line">			&lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/ssh&quot; /&gt;</span><br><span class="line">			&lt;!-- 数据库用户名 --&gt;</span><br><span class="line">			&lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">			&lt;!-- 数据库密码 --&gt;</span><br><span class="line">			&lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;111111&quot; /&gt;</span><br><span class="line"></span><br><span class="line">			&lt;!--jpa提供者的可选配置：我们的JPA规范的提供者为hibernate，所以jpa的核心配置中兼容hibernate的配 --&gt;</span><br><span class="line">			&lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">			&lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">			&lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;create&quot; /&gt;</span><br><span class="line">		&lt;/properties&gt;</span><br><span class="line">	&lt;/persistence-unit&gt;</span><br><span class="line">&lt;/persistence&gt;</span><br></pre></td></tr></table></figure>
<h2 id="主要的API"><a href="#主要的API" class="headerlink" title="主要的API"></a>主要的API</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  Persistence对象</span><br><span class="line">用于获取EntityManagerFactory对象的.Persistence.createEntityManagerFactory(unitName);</span><br><span class="line"></span><br><span class="line">#  EntityManagerFactory对象</span><br><span class="line">用来创建 EntityManager 实例。new EntityManagerFactory().createEntityManager();</span><br><span class="line"></span><br><span class="line">#  EntityManager是完成持久化操作的核心对象。</span><br><span class="line">主要通过该对象来完成持久化操作的核心操作</span><br><span class="line">    getTransaction : 获取事务对象</span><br><span class="line">    persist ： 保存操作</span><br><span class="line">    merge ： 更新操作</span><br><span class="line">    remove ： 删除操作</span><br><span class="line">    find/getReference ： 根据id查询</span><br><span class="line">    </span><br><span class="line">#  EntityTransaction 事务对象</span><br><span class="line">    begin：开启事务</span><br><span class="line">    commit：提交事务</span><br><span class="line">    rollback：回滚事务</span><br></pre></td></tr></table></figure>

<h2 id="简单的CRUD实现"><a href="#简单的CRUD实现" class="headerlink" title="简单的CRUD实现"></a>简单的CRUD实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void testGetOne() &#123;</span><br><span class="line">		// 定义对象</span><br><span class="line">		EntityManager em = null;</span><br><span class="line">		EntityTransaction tx = null;</span><br><span class="line">		try &#123;</span><br><span class="line">              // 获取实体管理对象</span><br><span class="line">          em = JPAUtil.getEntityManager();</span><br><span class="line">              // 获取事务对象</span><br><span class="line">          tx = em.getTransaction();</span><br><span class="line">              // 开启事务</span><br><span class="line">          tx.begin();</span><br><span class="line">              // 执行操作  CRUD</span><br><span class="line">          Customer c1 = em.find(Customer.class, 1L);</span><br><span class="line">              // 提交事务</span><br><span class="line">          tx.commit();</span><br><span class="line">          System.out.println(c1); // 输出查询对象</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">              // 回滚事务</span><br><span class="line">          tx.rollback();</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">              // 释放资源</span><br><span class="line">          em.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="JPA中的复杂查询"><a href="#JPA中的复杂查询" class="headerlink" title="JPA中的复杂查询"></a>JPA中的复杂查询</h2><p>JPQL全称是Java Persistence Query Languager。其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性。通过创建Query对象来进行查询<br>Query拥有许多的操作占位符、分页查询等等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查询所有客户</span><br><span class="line">	@Test</span><br><span class="line">	public void findAll() &#123;</span><br><span class="line">		EntityManager em = null;</span><br><span class="line">		EntityTransaction tx = null;</span><br><span class="line">		try &#123;</span><br><span class="line">			//获取实体管理对象</span><br><span class="line">			em = JPAUtil.getEntityManager();</span><br><span class="line">			//获取事务对象</span><br><span class="line">			tx = em.getTransaction();</span><br><span class="line">			tx.begin();</span><br><span class="line">			//创建query对象</span><br><span class="line">			String jpql = &quot;from Customer where custName like ? &quot;;</span><br><span class="line">			Query query = em.createQuery(jpql);</span><br><span class="line">			//对占位符赋值，从1开始</span><br><span class="line">			query.setParameter(1, &quot;传智播客%&quot;);</span><br><span class="line">			//查询并得到返回结果</span><br><span class="line">			List list = query.getResultList(); // 得到集合返回类型</span><br><span class="line">			for (Object object : list) &#123;</span><br><span class="line">				System.out.println(object);</span><br><span class="line">			&#125;</span><br><span class="line">			tx.commit();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// 回滚事务</span><br><span class="line">			tx.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			// 释放资源</span><br><span class="line">			em.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>Query还可以进行分页查询，通过属性设置起始索引和行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void findPaged () &#123;</span><br><span class="line">	EntityManager em = null;</span><br><span class="line">	EntityTransaction tx = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		//获取实体管理对象</span><br><span class="line">		em = JPAUtil.getEntityManager();</span><br><span class="line">		//获取事务对象</span><br><span class="line">		tx = em.getTransaction();</span><br><span class="line">		tx.begin();</span><br><span class="line">		//创建query对象</span><br><span class="line">		String jpql = &quot;from Customer&quot;;</span><br><span class="line">		Query query = em.createQuery(jpql);</span><br><span class="line">		//起始索引</span><br><span class="line">		query.setFirstResult(0);</span><br><span class="line">		//每页显示条数</span><br><span class="line">		query.setMaxResults(2);</span><br><span class="line">		//查询并得到返回结果</span><br><span class="line">		List list = query.getResultList(); //得到集合返回类型</span><br><span class="line">		for (Object object : list) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">		tx.commit();</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		// 回滚事务</span><br><span class="line">		tx.rollback();</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		// 释放资源</span><br><span class="line">		em.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><ul>
<li> Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架。通常使用Spring Data JPA + ORM（如：hibernate）完成操作。  </li>
<li> Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。</li>
</ul>
<h2 id="数据映射"><a href="#数据映射" class="headerlink" title="数据映射"></a>数据映射</h2><p>数据映射主要与JPA差不多，不做赘述。</p>
<h2 id="主要的API和接口"><a href="#主要的API和接口" class="headerlink" title="主要的API和接口"></a>主要的API和接口</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>父接口标记型接口，不包含任何方法.</p>
<h3 id="JpaRepository"><a href="#JpaRepository" class="headerlink" title="JpaRepository"></a>JpaRepository</h3><p>在父接口的基础上，提供了几个其他的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flush：立即生效（一般不用）</span><br><span class="line"></span><br><span class="line">saveAndFlush：保存并立即生效(save方法可能会有延迟，save操作后不会立即提交到数据库，有可能只是修改内存。)</span><br><span class="line"></span><br><span class="line">deleteInBatch：批量删除（delete是删除一个数据作为一个操作，batch是删除多个数据在同一个操作中。个人感觉可以对比JDBC中的批量执行sql，addBatch(sql)和executeBatch()，不知是否恰当）关于delete和deleteInBatch的区别可以参考：https://stackoverflow.com/questions/26142261/spring-jparepostory-delete-vs-deleteinbatch</span><br><span class="line"></span><br><span class="line">deleteAllInBatch：批量删除所有</span><br><span class="line"></span><br><span class="line">getOne：根据给定主ID查询，如果不存在抛EntityNotFoundException。返回的是实体类的一个引用</span><br></pre></td></tr></table></figure>

<h3 id="CrudRepository"><a href="#CrudRepository" class="headerlink" title="CrudRepository"></a>CrudRepository</h3><p>提供了简单的增删改查（crud）方法，继承后可以直接使用</p>
<h3 id="PagingAndSortingRepository"><a href="#PagingAndSortingRepository" class="headerlink" title="PagingAndSortingRepository"></a>PagingAndSortingRepository</h3><p>提供了简单的分页和排序功能，查询出所有数据后可以进行分页或者排序，需要传入Sort或者Pageable参数，设置分页或排序的规则。</p>
<h3 id="JpaSpecificationExecutor接口"><a href="#JpaSpecificationExecutor接口" class="headerlink" title="JpaSpecificationExecutor接口"></a><strong>JpaSpecificationExecutor接口</strong></h3><p><code>JpaSpecificationExecutor接口的使用一般要和Repository体系的接口一起使用，可以进行动态查询。不属于Repository体系，可以传入Specification 进行条件查询</code></p>
<h2 id="SpringDate-JPA使用"><a href="#SpringDate-JPA使用" class="headerlink" title="SpringDate JPA使用"></a>SpringDate JPA使用</h2><h3 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h3><ul>
<li> Springboot的配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: mysql123</span><br><span class="line">  jpa:</span><br><span class="line">    database: MySQL</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update    </span><br><span class="line">create：每次运行程序时，都会重新创建表，故而数据会丢失</span><br><span class="line">create-drop：每次运行程序时会先创建表结构，然后待程序结束时清空表</span><br><span class="line">upadte：每次运行程序，没有表时会创建表，如果对象发生改变会更新表结构，原有数据不会清空，只会更新（推荐使用）</span><br><span class="line">validate：运行程序会校验数据与数据库的字段类型是否相同，字段不同会报错</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li> 采用Bean对象的方式来配置<br>通过bean配置几个对象，且配置类添加@EnableSpringDataWebSupport 开启Springboot JPA的支持<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">// 借助spring data实现自动化的jpa repository，只需编写接口无需编写实现类</span><br><span class="line">// 相当于xml配置的&lt;jpa:repositories base-package=&quot;com.example.repository&quot; /&gt;</span><br><span class="line">// repositoryImplementationPostfix默认就是Impl</span><br><span class="line">// entityManagerFactoryRef默认就是entityManagerFactory</span><br><span class="line">// transactionManagerRef默认就是transactionManager</span><br><span class="line">@EnableJpaRepositories(basePackages = &#123;&quot;com.example.repository&quot;&#125;,</span><br><span class="line">        repositoryImplementationPostfix = &quot;Impl&quot;,</span><br><span class="line">        entityManagerFactoryRef = &quot;entityManagerFactory&quot;,</span><br><span class="line">        transactionManagerRef = &quot;transactionManager&quot;)</span><br><span class="line">@EnableTransactionManagement    // 启用事务管理器</span><br><span class="line">@EnableSpringDataWebSupport     // 启用springmvc对spring data的支持</span><br><span class="line">public class SpringDataJpaConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 配置jpa厂商适配器</span><br><span class="line">    @Bean</span><br><span class="line">    public JpaVendorAdapter jpaVendorAdapter() &#123;</span><br><span class="line">        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();</span><br><span class="line">        // 设置数据库类型（可使用org.springframework.orm.jpa.vendor包下的Database枚举类）</span><br><span class="line">        jpaVendorAdapter.setDatabase(Database.MYSQL);</span><br><span class="line">        // 设置打印sql语句</span><br><span class="line">        jpaVendorAdapter.setShowSql(true);</span><br><span class="line">        // 设置不生成ddl语句</span><br><span class="line">        jpaVendorAdapter.setGenerateDdl(false);</span><br><span class="line">        // 设置hibernate方言</span><br><span class="line">        jpaVendorAdapter.setDatabasePlatform(&quot;org.hibernate.dialect.MySQL5Dialect&quot;);</span><br><span class="line">        return jpaVendorAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置实体管理器工厂</span><br><span class="line">    @Bean</span><br><span class="line">    public LocalContainerEntityManagerFactoryBean entityManagerFactory(</span><br><span class="line">            DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) &#123;</span><br><span class="line">        LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();</span><br><span class="line">        // 注入数据源</span><br><span class="line">        emfb.setDataSource(dataSource);</span><br><span class="line">        // 注入jpa厂商适配器</span><br><span class="line">        emfb.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class="line">        // 设置扫描基本包</span><br><span class="line">        emfb.setPackagesToScan(&quot;com.example.entity&quot;);</span><br><span class="line">        return emfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置jpa事务管理器</span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) &#123;</span><br><span class="line">        JpaTransactionManager transactionManager = new JpaTransactionManager();</span><br><span class="line">        // 配置实体管理器工厂</span><br><span class="line">        transactionManager.setEntityManagerFactory(emf);</span><br><span class="line">        return transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> XmL的方式配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1.dataSource 配置数据库连接池--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/jpa&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;111111&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 2.配置entityManagerFactory --&gt;</span><br><span class="line">&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;packagesToScan&quot; value=&quot;cn.itcast.entity&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;persistenceProvider&quot;&gt;</span><br><span class="line">		&lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot; /&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;!--JPA的供应商适配器--&gt;</span><br><span class="line">	&lt;property name=&quot;jpaVendorAdapter&quot;&gt;</span><br><span class="line">		&lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;generateDdl&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">       &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot; /&gt;</span><br><span class="line">			&lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot; /&gt;</span><br><span class="line">			&lt;property name=&quot;showSql&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;jpaDialect&quot;&gt;</span><br><span class="line">		&lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot; /&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">&lt;!-- 3.事务管理器--&gt;</span><br><span class="line">&lt;!-- JPA事务管理器  --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 整合spring data jpa--&gt;</span><br><span class="line">&lt;jpa:repositories base-package=&quot;cn.itcast.dao&quot;</span><br><span class="line">	transaction-manager-ref=&quot;transactionManager&quot;</span><br><span class="line">	entity-manager-factory-ref=&quot;entityManagerFactory&quot;&gt;&lt;/jpa:repositories&gt;</span><br><span class="line">	</span><br><span class="line">&lt;!-- 4.txAdvice--&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">	&lt;tx:attributes&gt;</span><br><span class="line">		&lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">	&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 5.aop--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.itcast.service.*.*(..))&quot; /&gt;</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot; /&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line"> &lt;!-- 6.扫描包--&gt;</span><br><span class="line"> 	&lt;context:component-scan base-package=&quot;cn.itcast&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ul>
<li> 创建Repository继承接口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li> 测试代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;) xml配置方式</span><br><span class="line">public class CustomerDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CustomerDao customerDao;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 保存客户：调用save(obj)方法</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testSave() &#123;</span><br><span class="line">        Customer c = new Customer();</span><br><span class="line">        c.setCustName(&quot;传智播客&quot;);</span><br><span class="line">        customerDao.save(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承接口自定义方法"><a href="#继承接口自定义方法" class="headerlink" title="继承接口自定义方法"></a>继承接口自定义方法</h2><ul>
<li><p> 接口中Query注解<br>两种查询语句 一种是查询对象， 一种是本地sql 使用本地sql需要设置nativeQuery=true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;,JpaSpecificationExecutor&lt;Customer&gt; &#123;  </span><br><span class="line">    //@Query 使用jpql的方式查询(对象)。?1代表参数的占位符，其中1对应方法中的参数索引</span><br><span class="line">    @Query(value=&quot;from Customer where custName = ?1&quot;)</span><br><span class="line">    public Customer findCustomer(String custName)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // nativeQuery : 使用本地sql的方式查询。数据库查询语句</span><br><span class="line">        @Query(value=&quot;select * from cst_customer&quot;,nativeQuery=true)</span><br><span class="line">    public void findSql();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> 接口中关键字自定义方法</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface CustomerDao extends JpaRepository&lt;Customer, Long&gt;,JpaSpecificationExecutor&lt;Customer&gt; &#123;  </span><br><span class="line">    //方法命名方式查询（根据客户名称查询客户）通过关键字 例如  like  by order等等</span><br><span class="line">    public Customer findByCustName(String custName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">And         --- 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</span><br><span class="line">Or          --- 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</span><br><span class="line">Between     --- 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</span><br><span class="line">LessThan    --- 等价于 SQL 中的 &quot;&lt;&quot;，比如 findBySalaryLessThan(int max)；</span><br><span class="line">GreaterThan --- 等价于 SQL 中的&quot;&gt;&quot;，比如 findBySalaryGreaterThan(int min)；</span><br><span class="line">IsNull      --- 等价于 SQL 中的 &quot;is null&quot;，比如 findByUsernameIsNull()；</span><br><span class="line">IsNotNull   --- 等价于 SQL 中的 &quot;is not null&quot;，比如 findByUsernameIsNotNull()；</span><br><span class="line">NotNull     --- 与 IsNotNull 等价；</span><br><span class="line">Like        --- 等价于 SQL 中的 &quot;like&quot;，比如 findByUsernameLike(String user)；</span><br><span class="line">NotLike     --- 等价于 SQL 中的 &quot;not like&quot;，比如 findByUsernameNotLike(String user)；</span><br><span class="line">OrderBy     --- 等价于 SQL 中的 &quot;order by&quot;，比如 findByUsernameOrderBySalaryAsc(String user)；</span><br><span class="line">Not         --- 等价于 SQL 中的 &quot;！ =&quot;，比如 findByUsernameNot(String user)；</span><br><span class="line">In          --- 等价于 SQL 中的 &quot;in&quot;，比如 findByUsernameIn(Collection&lt;String&gt; userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</span><br><span class="line">NotIn       --- 等价于 SQL 中的 &quot;not in&quot;，比如 findByUsernameNotIn(Collection&lt;String&gt; userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</span><br></pre></td></tr></table></figure>


<h2 id="JpaSpecificationExecutor接口的动态查询"><a href="#JpaSpecificationExecutor接口的动态查询" class="headerlink" title="JpaSpecificationExecutor接口的动态查询"></a>JpaSpecificationExecutor接口的动态查询</h2><p>此接口不属于Repository体系，可以传入Specification以及page分页的对象。完成操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *	JpaSpecificationExecutor中定义的方法</span><br><span class="line"> **/</span><br><span class="line"> public interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">   	//根据条件查询一个对象</span><br><span class="line"> 	T findOne(Specification&lt;T&gt; spec);	</span><br><span class="line">   	//根据条件查询集合</span><br><span class="line"> 	List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</span><br><span class="line">   	//根据条件分页查询</span><br><span class="line"> 	Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">   	//排序查询查询</span><br><span class="line"> 	List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">   	//统计查询</span><br><span class="line"> 	long count(Specification&lt;T&gt; spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Specification完成条件查询"><a href="#使用Specification完成条件查询" class="headerlink" title="使用Specification完成条件查询"></a>使用Specification完成条件查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	//依赖注入customerDao</span><br><span class="line">	@Autowired</span><br><span class="line">	private CustomerDao customerDao;	</span><br><span class="line">	@Test</span><br><span class="line">	public void testSpecifications() &#123;</span><br><span class="line">      	//使用匿名内部类的方式，创建一个Specification的实现类，并实现toPredicate方法</span><br><span class="line">		Specification &lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123;</span><br><span class="line">			public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line">      </span><br><span class="line">      //cb:构建查询，添加查询方式   like：模糊匹配</span><br><span class="line">			//root：从实体Customer对象中按照custName属性进行查询</span><br><span class="line">        </span><br><span class="line">				return cb.like(root.get(&quot;custName&quot;).as(String.class), &quot;传智播客%&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Customer customer = customerDao.findOne(spec);</span><br><span class="line">		System.out.println(customer);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">equle                                      filed = value</span><br><span class="line">gt（greaterThan ）	                       filed &gt; value</span><br><span class="line">lt（lessThan ）	                           filed &lt; value</span><br><span class="line">ge（greaterThanOrEqualTo ）	               filed &gt;= value</span><br><span class="line">le（ lessThanOrEqualTo）	                 filed &lt;= value</span><br><span class="line">notEqule	                                filed != value</span><br><span class="line">like	                                    filed like value</span><br><span class="line">notLike	                                  filed not like value</span><br></pre></td></tr></table></figure>

<h3 id="分页查询-1"><a href="#分页查询-1" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void testPage() &#123;</span><br><span class="line">		//构造查询条件</span><br><span class="line">		Specification&lt;Customer&gt; spec = new Specification&lt;Customer&gt;() &#123;</span><br><span class="line">			public Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line">				return cb.like(root.get(&quot;custName&quot;).as(String.class), &quot;传智%&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    /**</span><br><span class="line">		 * 构造分页参数</span><br><span class="line">		 * 		Pageable : 接口</span><br><span class="line">		 * 			PageRequest实现了Pageable接口，调用构造方法的形式构造</span><br><span class="line">		 * 				第一个参数：页码（从0开始）</span><br><span class="line">		 * 				第二个参数：每页查询条数</span><br><span class="line">		 */</span><br><span class="line">		Pageable pageable = new PageRequest(0, 5);</span><br><span class="line">		</span><br><span class="line">		/**</span><br><span class="line">		 * 分页查询，封装为Spring Data Jpa 内部的page bean</span><br><span class="line">		 * 		此重载的findAll方法为分页方法需要两个参数</span><br><span class="line">		 * 			第一个参数：查询条件Specification</span><br><span class="line">		 * 			第二个参数：分页参数</span><br><span class="line">		 */</span><br><span class="line">		Page&lt;Customer&gt; page = customerDao.findAll(spec,pageable);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">返回的Page对象的方法：</span><br><span class="line"> </span><br><span class="line">int getTotalPages();      //获取总页数</span><br><span class="line">	</span><br><span class="line">long getTotalElements();  //获取总记录数	</span><br><span class="line"></span><br><span class="line">List&lt;T&gt; getContent();     //获取列表数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>Spring Date JPA的学习</category>
      </categories>
      <tags>
        <tag>Spring Date  JPA</tag>
      </tags>
  </entry>
</search>
